# 网络请求C10K与C1000K

- C10K:代表的是单机处理**1万个请求**。
- C1000K:代表的是单机处理**100万个请求**。

## 两个问题：

1. 一个线程内处理多个请求，就是要一个线程内响应多个网络I/O，
2. 节省资源的方式来处理客户端请求，用更少的线程来服务这些请求。

## i/O模型

IO事件的通知方式，水平触发与边缘触发。

- 水平触发： 文件描述符可以非阻塞的执行IO，那么就会触发通知，应用程序检查文件描述符的状态进行IO操作。
- 边缘触发： 文件描述符的状态发生改变时，才发送通知。应用程序会尽可能多的执行IO,如果IO没有执行完毕，那么这次通知也会丢失。

### 使用非阻塞IO和水平触发通知。

在这里选择的是select或者poll方式。

select或者poll需要从文件描述符的列表中找出哪些是可以执行IO的然后进行读写，并且，一个线程可以监控一批套接字信息，达到出路多请求的目的。

- select: 固定长度的位向量，表示文件描述符的集合，会有数量的限制。
- poll: 没有固定长度的数组，没有最大描述符数量的限制，受系统文件描述符的限制。同样采用了轮训的方式。
  
还有两个问题点：

1. select 耗时与轮训的关系是O(n^2)的关系，poll是O(N)的关系。
2. 描述符的集合每次需要从用户空间传到内核空间，内核空间做操作之后，才返回给用户空间，耗时成本增加。

### 非阻塞IO与边缘触发

epoll解决上面问题。

- 采用红黑树，在内核中管理集合不用应用程序每次操作从用户到内核，再从内核到用户。
- 事件驱动，有关注这个IO事件的才会被通知，不需要进行轮训。
  
### 异步IO

异步io能允许应用程序同时发起很多IO操作，后期可以通过事件通知的方式返回去。

## 工作模型

### 主进程+ 多个worker子进程

- 主进程执行bind() + 监听，创建多个子进程。
- 然后每个子进程进行事件的接收与epoll_wait(),处理相同的套接字。
  
### 监听相同端口的多进程模型

所有进程监听相同的接口，并开启SO_REUSEPORT选项，让内核去做监听这些进程。

