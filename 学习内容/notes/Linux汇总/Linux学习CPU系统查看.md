# CPU监控学习

## 前言

作为一名开发，我们绕不过去的一道坎是在服务器上对系统进行监控，并且当系统出现异常情况，需要快速排查，我们今天了解的平均负载就是监控中重要的一环。

在学习**平均负载**之前，我们需要了解相关指标，根据指标看清楚相关问题。正因为如此，我们从浅入深了解如下知识。

1. 常用的相关命令
2. 平均负载
3. 相关工具了解
4. 案例解析

## 常用的相关命令

常用的top命令，uptime命令，htop命令命令。

### top

常用的性能分析工具，可以实时动态的查看系统整体情况和各个进程的资源占用情况，top命令提供动态互动式界面，还提供了热键式操作。

关于top命令详解可以参考 https://man.linuxde.net/top.
有top命令的详细解析。该网站提供很多命令查询，如果命令忘记了可以上去查询。

> 注意：该网站是一个可以被收藏的工具网站

![2019-08-29-23-24-24](http://jikelearn.cn/2019-08-29-23-24-24.png)

### uptime

显示系统运行时间与系统的平均负载，显示时间依次为：现在时间，系统已经运行了多长时间，几个在线用户，平均负载。 可以结合**watch**使用。

```linux
ruiqi@ruiqi:~/content$ uptime
15:24:41 up 3 min,  2 users,  load average: 0.34, 0.48, 0.22
```

### htop

htop是比top更详细的监控软件，操作上更加方便。有如下优势：

1. 操作上比top相对来说简单
2. 默认支持图形界面的鼠标操作
3. 横向或者纵向的浏览进程列表，查看所有进程，当然也包括完整的命令行。

还有更多的操作技巧，htop在各家的linux系统中并没有默认安装，需要在各家系统上进行安装。
展示方式也跟top有类似的参照。
![2019-08-29-23-35-32](http://jikelearn.cn/2019-08-29-23-35-32.png)

## 平均负载

### 什么是平均负载

在上面每个命令，都可以看到**load average**参数，这是平均负载的英文标识。三个顺序分别为1min，5min,15min。

可能会有朋友说，平均负载不就是CPU使用率嘛？这句话说对也对，说不对也不对。

那怎么说呢？

一般分析负载情况可以分为以下三种：

1. CPU密集型进程，需要大量消耗CPU资源，这时候大量的CPU消耗会导致平均负载的升高。
2. IO密集型进程，需要等待IO，这时候也会导致负载的增高，但这种情况CPU的使用并不高。
3. 还有一种就是等待CPU的情况，此时CPU消耗很高，cpu的等待也很高，平均负载也是很高的。

**说了平局负载升高的情况，那平均负载究竟是什么呢？**

在了解平均负载之前，先了解下Linux中进程的几种状态：

- TASK_RUNNINT: 简称**R**,可执行状态
- TASK_INTERRUPTIBLE:简称**S**，可中断的睡眠状态，能够响应信号。
- TASK_UNINTERRUPTIBLE:简称**D**,不可中断的睡眠状态。该状态主要是显示内核在处理一些流程时，是不可中断的，不可中断状态可以认为是一种保护机制，来保证系统对进程和设备之间的一致性。
- TASK_STOPPED || TASK_TRACED:简称**T**,暂停状态或跟踪状态，
- TASK_DEAD - EXIT_ZOMBIE :简称**Z**,退出状态，进程为僵尸进程，该进程不可被kill，不响应任务信号。
- TASK_DEAD-EXIT_DEAD: 简称**X**,退出状态，进程即将被销毁。

平均负载呢，可以简单地理解为在一定时间内，系统处于**可运行状态**和**不可中断状态**的平均进程数。

1. 可运行状态就是我们上面所说的TASK_RUNNING,可运行状态，该状态包含正在使用CPU或者等待CPU的进程。
2. 不可中断状态的进程:是我们上面所说的TASK_UNINTERRUPTIBLE,简称D的进程。

所以我们可以看到平均负载并不只是可运行状态的进程，还包含着不可中断的进程。

### 平均负载的评判标准

利用所说的top，uptime，htop命令，很方便的查看系统现在负载的状况。

但平均负载究竟是多少才算是不合理的数据呢？由于每个服务器或者客户机所拥有的的硬件配置不同，我们并不能简简单单的定义一个具体数值来说明平均负载的好与坏。

但我们了解**平均负载最理想的情况就是等于CPU的个数**，根据这一条，我们首先确定机器的CPU个数，方式有多种。

#### CPU的个数

- 从文件中读取
  
  ```linux
    $ grep 'model name' /proc/cpuinfo
    model name      : Intel(R) Core(TM) i7-6700K CPU @ 4.00GHz
    model name      : Intel(R) Core(TM) i7-6700K CPU @ 4.00GHz

    或者再用wc -l 统计一下
    $ grep 'model name' /proc/cpuinfo | wc -l
    2

  ```

- top/htop
  使用top 再按快捷键1就可以看出有多少个CPU
  ![2019-08-31-12-38-45](http://jikelearn.cn/2019-08-31-12-38-45.png)
  使用htop，看数字可以看出有多少CPU
  ![2019-08-31-12-39-28](http://jikelearn.cn/2019-08-31-12-39-28.png)

#### 评断标准

了解CPU个数之后，视角转回到**load average**上，发现该参数有三个数值，分别为1m，5m,15m,那我们该用哪个时间代表负载的标准呢？

其实也很简单，他们分表代表的是1m，5m，15m内的负载均值情况，代表这段时间内负载运行的趋势。根据不同时间内的值大小，可以评判出系统负载变化的趋势，方便得出平均负载的变化。一般情况下，超过系统可容纳负载70%的时候，监控人员就需要引起注意，并查看系统是否出现异常情况。

当然该70%只是理论值，需要根据不同的机器做不同的判断，比如服务器属于老旧服务器，对于其负载指标可以降低负载均值。负载过高时，及时作出应急措施。

## 相关工具了解

由于我们并没有实际的环境实现，则需要我们进行环境的模拟，那么在实现案例之前需要先学习相关工具，帮助我们辅助实验环境的搭建

### Stress

stress 是压力测试工具，是Posix系统下生成CPU/Menory/IO/Disk负载的工具

#### Stress 安装

- ubuntu上安装

```ubuntu
sudo apt-get install stress
```

- centos 安装

```centos
Centos 7

## 启用第三方源
rpm  -ivh http://apt.sw.be/redhat/el7/en/x86_64/rpmforge/RPMS/rpmforge-release-0.5.3-1.el7.rf.x86_64.rpm

## 安装stress
yum install stress

Centos 6
## 启用三方源
yum install epel-release

## 安装Stress
yum install stress

```

#### Stress 参数说明

```linux

-? 显示帮助信息
-v 显示版本号
-q 不显示运行信息
-n，--dry-run 显示已经完成的指令执行情况
-t --timeout N 指定运行N秒后停止
   --backoff N 等待N微妙后开始运行
-c --cpu 产生n个进程 每个进程都反复不停的计算随机数的平方根
-i --io  产生n个进程 每个进程反复调用sync()，sync()用于将内存上的内容写到硬盘上
-m --vm n 产生n个进程,每个进程不断调用内存分配malloc和内存释放free函数
   --vm-bytes B 指定malloc时内存的字节数 (默认256MB)
   --vm-hang N 指示每个消耗内存的进程在分配到内存后转入休眠状态，与正常的无限分配和释放内存的处理相反，这有利于模拟只有少量内存的机器
-d --hadd n 产生n个执行write和unlink函数的进程
   --hadd-bytes B 指定写的字节数，默认是1GB
   --hadd-noclean 不要将写入随机ASCII数据的文件Unlink
时间单位可以为秒s，分m，小时h，天d，年y，文件大小单位可以为K，M，G

```

#### Stress 使用教程

- 多CPU
  
  ```linux
  stress -c 13
  ```
  
  ![2019-08-31-00-57-02](http://jikelearn.cn/2019-08-31-00-57-02.png)
- 多io操作
  
  ```linux
    stress --io 5
    stress -i 5
  ```

- 产生多个CPU与多个io进程并且定时1分钟停止
  
  ```Linux
    stress -c 4 -i 4 --timeout 1m
    stress: info: [19613] dispatching hogs: 4 cpu, 4 io, 0 vm, 0 hdd
    stress: info: [19613] successful run completed in 60s
  ```

- 输出文件到本地
  
  ```Linux
    stress -d 1 --hdd-bytes 1G
  ```

当然stress并不止这些内容，但有一点注意**stress无法模拟更复杂的场景**，并且stress的压力CPU是在用户态，内核态并没有产生压力。如果需要更复杂的压力测试我们还可以使用stress-ng。

### sysstat

sysstat是常用的性能监控工具包，里面包含了多个性能工具。比如我们下面要用的mpstat,pidstat,iostat,sar等指令。

#### 安装

1. ubuntu

```linux
sudo apt-get install sysstat
```

2.centos

```centos
yum install sysstat
```

#### mpstat

mpstat会输出所有CPU的平均统计信息

命令使用：

```linux
~$ mpstat -A  该命令等同于我们 mpstat -u -l ALL  -p ALL
Linux 4.15.0-55-generic (ruiqi)         08/31/2019      _x86_64_        (2 CPU)

07:15:31 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
07:15:31 AM  all    0.77    0.01    1.83   17.85    0.00    0.21    0.00    0.00    0.00   79.32
07:15:31 AM    0    0.74    0.01    1.42   16.58    0.00    0.42    0.00    0.00    0.00   80.83
07:15:31 AM    1    0.81    0.02    2.25   19.11    0.00    0.01    0.00    0.00    0.00   77.81

07:15:31 AM NODE    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
07:15:31 AM  all    0.77    0.01    1.83   17.85    0.00    0.21    0.00    0.00    0.00   79.32
07:15:31 AM    0    0.76    0.01    1.80   17.49    0.00    0.21    0.00    0.00    0.00   77.70

07:15:31 AM  CPU    intr/s
07:15:31 AM  all    177.24
07:15:31 AM    0    118.28
07:15:31 AM    1    119.02

07:15:31 AM  CPU        0/s        1/s        6/s        8/s        9/s       12/s       14/s       15/s       16/s       17/s       18/s       19/s       24/s       25/s       26/s       27/s       28/s       29/s       30/s       31/s       32/s       33/s       34/s       35/s       36/s       37/s       38/s       39/s       40/s       41/s       42/s       43/s       44/s       45/s       46/s       47/s       48/s       49/s       50/s       51/s       52/s       53/s       54/s       55/s       56/s       57/s       58/s      NMI/s      LOC/s      SPU/s      PMI/s      IWI/s      RTR/s      RES/s      CAL/s      TLB/s      TRM/s      THR/s      DFR/s      MCE/s      MCP/s      HYP/s      ERR/s      MIS/s      PIN/s      NPI/s      PIW/s
07:15:31 AM    0       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00      42.52       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.59       0.13       0.00       0.00      41.94       0.00       0.00       0.00       0.00      16.35       0.18       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00
07:15:31 AM    1       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       2.89       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.27       0.00       0.00       0.00      55.25       0.00       0.00       0.00       0.00      17.08       0.04       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00       0.00

07:15:31 AM  CPU       HI/s    TIMER/s   NET_TX/s   NET_RX/s    BLOCK/s IRQ_POLL/s  TASKLET/s    SCHED/s  HRTIMER/s      RCU/s
07:15:31 AM    0       0.00      28.96       0.19       0.00      42.85       0.00       0.13      25.51       0.00      20.65
07:15:31 AM    1       0.00      45.75       0.00       2.89       0.25       0.00       0.08      41.03       0.00      29.01
```

命令说明：

- P:  携带ALL, 将每个CPU的统计信息进行输出。

   ```linux
   ruiqi@ruiqi:~$ mpstat -P ALL
    Linux 4.15.0-55-generic (ruiqi)         08/31/2019      _x86_64_        (2 CPU)

    07:17:31 AM  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
    07:17:31 AM  all    0.77    0.01    1.83   17.83    0.00    0.21    0.00    0.00    0.00   79.34
    07:17:31 AM    0    0.74    0.01    1.42   16.57    0.00    0.42    0.00    0.00    0.00   80.85
    07:17:31 AM    1    0.80    0.02    2.25   19.09    0.00    0.01    0.00    0.00    0.00   77.83

   ```

- N: 代表每隔几秒输出CPU的信息
- I: 代表输出每个处理器的中断统计信息
- u: 代表输出所有CPU的统计信息

### pidstat

pidstat 用来监控进程和当前受内核管理的线程，并且还可以检查子进程和线程的状态

```linux
pidstat -t -p 进程号 2 3  #每隔两秒对指定进程的cpu信息统计输出3次
pidstat -p ALL  # 展示所有进程信息
pidstat -u 5 1 # 展示CPU信息，每五秒展示一组
pidstat -d 2 # 输出io统计消息, 2秒为统计信息

```

## 案例

从上面例子可以看到负载升高的几种情景，为了帮助我们理解这方面的内容，则我们创建一个例子来演示下。

### 机器环境如下

搭建虚拟机环境：

- 双核
- 内存是2g
- 操作系统是ubuntu18.04
- 安装stress,top，htop
  
### CPU密集型进程

CPU密集型进程，需要大量消耗CPU资源，这时候大量的CPU消耗会导致平均负载的升高。
借助stress 模拟CPU密集进程。

```Linux
stress -c 10  --timeout 600
```

使用top命令查看平均负载。

![2019-08-31-14-53-58](http://jikelearn.cn/2019-08-31-14-53-58.png)

从图上可看到load average 正在逐步的升高。系统已经进入高负载。

mpstat -p ALL 显示所有信息，检查是什么导致负载升高

![2019-08-31-20-37-36](http://jikelearn.cn/2019-08-31-20-37-36.png)
由图上可知，CPU的使用率基本上都为100%而iowait等待则为0，代表平均负载的升高是由CPU使用率高导致的。

那究竟怎么看是哪一个进程导致CPU使用率这么高的，在这里就可以使用pidstat命令查看。

```linux
pidstat -p ALL  # 展示所有进程信息
pidstat -u 5 1 # 展示CPU信息，每五秒展示一组
pidstat -d 2 # 输出io统计消息, 2秒为统计信息
pidstat -t -p 进程号 2 3  #每隔两秒对指定进程的cpu信息统计输出3次
```

### other

IO密集型进程，需要等待IO，这时候也会导致负载的增高，但这种情况CPU的使用并不高，多进程的方式造成的负载升高。

这两种情况都是使用mpstat来观察负载，找到cpu超标还是io等待或者是进程多导致cpu等待造成的负载升高，最后使用pidstat找到对应的进程，检查其情况。

## 总结

本文主要描述平均负载来源，顺带的说了下压力测试工具stress,stress-ng,mpstat,pidstat指令。

用这些工具辅助我们来进行系统监控与问题查找。
