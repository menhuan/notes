# 散列表

散列表其实根据数组按照下标随机访问数据的特性而衍生出来的数据。

将数组中的下标当做散列表中的key，下标中对应的值当做我们的散列值。

散列表用的是数组支持下标随机访问的特性，利用**时间复杂度O(1)的特性**，快速的查找数据。

## 散列函数

在散列表中，利用元素的键值，作为下标，然后将数组存储在对应的位置上。

散列函数其实就是hash(key)。

hash函数有很多种 比如MD5,SHA,CRC等哈希算法，但是有一个特点是都不能完美的避免散列冲突。

数组存储的空间有限，那么就会增大散列冲突的概率。

## 散列冲突

散列冲突怎么解决呢？

### 开放寻址法

在散列函数中，如果出现哈希冲突，那么就会寻找下一个空闲位置，将其数据插入。

方法有**线性探测**。

#### 查找

查找的过程也是类似的，取出hash对应的值，与需要查找的元素对比，符合就取出，不符合就继续查找，遇到空闲位置就终止，则代表没有元素

#### 删除

线性探测的时候，删除数据并不是真的删除，而是标记为deleted，当查找的时候遇到该元素，继续往下面寻找空闲位置。

其他方法，二次探测与双重散列。

但是都有个问题是当空间不足的时候，冲突就会增加。这时候就需要考虑数组扩容的问题

#### 装载因子

尽可能的保证散列中存在一定比例的空闲槽位，用因子来表示空位的多少。

公式： **散列表的装载因子 = 填入表中的元素个数/散列表的长度**

因子越大，空闲位置越少，冲突也就越多，性能就会下降。

### 链表法

![摘自极客时间](http://jikelearn.cn/2019-04-15-22-48-09.png)

将hash函数计算出来的key 放入数组中，也就是所说的槽中。在每一个槽后面对应的是一个链表。

遇到哈希冲突，就可以将数据插入到链表中。查询的时候叶需要查询链表。则如果冲突比较多，那么会出现查找时间是O（N）的情景。
