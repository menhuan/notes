# 算法学习笔记

算法中询问的三个问题。

1. 该算法是否是原地算法，原理：空间复杂度是O(1)
2. 该算法是否是稳定算法，两个值相等的在执行算法完毕后是否是有序的
3. 该算法的时间复杂度如何，最好，最坏，与平均

## 归并算法

归并算法中使用的是分而治之的编程思想。

对要排序的序列先进性拆分，排序好之后再进行合并。拆分是利用的递归思想，注意截止条件的设置。

![摘自极客时间](http://jikelearn.cn/2019-04-07-22-24-38.png)

实现代码：

```Java
代码周末实现，突然感觉补的代码好多
```

### 三个问题问答

1. 该算法是否是原地算法？归并算法在拆分之后，两两进行比较，再进行合并，使用swap交换，合并的时候，需要借助外界的临时空间，空间大小等于两个拆分的空间大小之和，则**不是原地算法**。
2. 是否是稳定算法？稳定算法是排序的时候两个相等的值是否还具有原先的先后顺序，从图上可看到，在合并的前后，把在前面的元素先放到临时数组中，就可以保证原先相等值得先后顺序，则代表该算法是稳定算法。
3. 时间复杂度都是O(n*logn)，最好，最坏，平均都是

缺点是不是原地算法，需要借助外界的空间来保存数据空间复杂度是0(n).

## 快排

快排利用的思想也是分而治之。核心思想是**选择一个分区点pivot，从数据中选择一个**。

再根据分区点将数据一分为三，通过游标的方式将数据数据整合成**已处理区**与**未处理区**。
![快排实现的图，摘自极客时间](http://jikelearn.cn/2019-04-07-22-54-48.png)

### 三个问题

1. 该算法是否是原地算法，我么能在实现的时候使用了已处理区与未处理区，只进行数据的交换空间复杂度是O(1),则是**原地算法**。
2. 稳定算法？在处理已处理区的与未处理区的时候涉及到分区的操作，并不能保证数据的先后性。
3. 时间复杂度都是O(nlogn)。

## 总结思考问题

快排思想O（n）内查找最第K大元素。

快排分为了三部分，则查找到K大元素，需要根据分区点再在范围内寻找。

第一次：根据选择的分区点进行分区，遍历n个元素。
第二次：根据分区点找到第二次分区的数据范围，再次查找数据进行分区。
...
第n次。。

根据大O算法可知，时间复杂度是o(n).N比较大，则系数可去掉。
