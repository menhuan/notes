# 需要二叉树的原因

二叉查找树：在树中的任意一个节点，其左子树中的每个节点的值都要小于这个**节点的值**，而右子树节点的值大于这个节点的值。

![摘自极客时间](http://jikelearn.cn/2019-04-28-22-29-44.png)

## 二叉查找树的查找操作

二叉查找数据的查询数据从根节点开始查找，由于左右子树有大小区分，则进行比较，再进行递归查找到需要的数据。

```Java

//代码实现
```

## 插入操作

插入操作，也是先从根节点开始遍历数据，进行比较大小，

- 小：如果左子树为空 直接放入数据，如果不为空，则再依次比较。
- 大：如果右子树为空，直接放入数据，如果不为空，循环这个比较过程，直到找到空的位置即可。

```Java
//代码实现
```

### 二叉查找树的其他操作

支持快速的查找到最大节点与最小节点，前驱节点与后驱节点。

- 中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度O(N)。

```Java

//代码实现时间复杂度
```

## 支持重复查找的二叉查找树

两种实现方式。

### 链表或者其他数据结构存储

借助哈希冲突实现的方式，当有数据相同时，将属于一个节点的数据进行共同存储。

### 另外一种方法

每个节点都只存储一个数据，在查找插入位置的过程中，如果碰到与插入的值相同，将其插入到右子树中。相当于右子树存储大于等于的值。

删除操作按照查找的流程一步步的删除即可。

## 时间复杂度

二叉查找树可能会出现极端情况，数据退化成链表形式，时间复杂度是O(n).

正常情况来说二叉树的时间复杂度是O（树的高度）。

### 怎么求一个完全二叉树的高度

等比公式：

```Java
 第一层 1
 第二层 ：2

 第三次： 2*2
 ...

 第n层： 2*(n-1)
```

当最大层数是L ,当节点数在1到2^(n-1) 之间，累计加起来节点数符合下面规则：

```Java
n>= 1+2+4...2^(L-2) +1, +1 代表叶子节点只有一个
n<= 1+2+4...2^(L-2)+2^(L-1)，代表叶子节点满了
```

将上面求和，则是[log2(n+!),log2n +1];
