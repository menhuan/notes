时间复杂度是线性的，这类排序算法叫做线性排序。
三个算法是 基于比较的排序算法，不设计元素之间的比较操作，所以能做到线性的时间复杂度。
# 桶排序
核心思想是将要排序的数据分到几个有序的桶内，每个桶内的数据进行单独排序，拍好之后把桶内的数据取出来，组成的序列就是有序的。时间复杂度是O(n).桶内部采用的是快速排序手段
![摘自极客时间](https://upload-images.jianshu.io/upload_images/4237685-f530ca214c10447b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

首先桶排序要把数据进行划分到m个桶内，希望的是桶内数据是均匀的，并且桶与桶之间有着天然的大小顺序。
极端情况下时间复杂度会退化为O(nlog n);
比较适合外部排序。
在进行划分桶数据的时候，可能存在桶数据不均匀的情况，可以选择在多的数据桶进行继续划分桶，直到桶数据可以加载到内存中为止。
# 计数排序
桶排序的一种特殊情况。范围不是很大。最大值是K直接化为K个桶。桶内数值是相等的。
计数排序的原则
- 把一系列的数字统计个数放在数组内A。
- 依次累加，统计结果还是在同一个数组中存放A。
- 临时数组C存放排序后的结果。
- 遍历最初时的数据B，从A中找到该值。
- A数组中的值-1就是数据B在临时数组C存放的位置。
- 把A数组中的值减1.
- 循环这个过程
![摘自极客时间](https://upload-images.jianshu.io/upload_images/4237685-cdad8a3133d989e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

该计数规则只适合 **数据范围不大的情景**

## 基数排序
基数排序要对排序的数据有要求，分割独立的位出来比较。
从高位开始进行比较，高位相同，比较低位。数据范围不能太大。
需要借助桶排序，或者计数排序完成每一个位的排序工作。

## 实战问题
100万用户排序，根据桶算法，根据用户年龄分桶，比如1-120 。那么分为120个桶。
遍历元素，放入到桶中既可以得到有序的好的数据。
桶中用快排的方式进行排序。
