# 搜索算法

算法是用于具体的数据结构当中，搜索算法很多都是建立在图这种数据结构的。这是因为图的表达能力很强，大部分的搜索场景都可以**抽象**成图。

```Java
//图的实现

```

## 广度优先算法

广度优先算法又被称为BFS,地毯式的搜索。

```Java
//todo 代码实现

```

![2019-05-15-23-30-00](http://jikelearn.cn/2019-05-15-23-30-00.png)

- visited 是用来记录被访问的顶点，用来拒绝避免顶点被重复访问。如果某个顶点被访问到那么在visited[下标顶点]位置存储的数据存为1.
- queue 是一个队列，用来存储已经被访问的顶点，然后相连的顶点还没有被访问的顶点。
- prev是用来存储搜索路径的。存储路径是相反的，prew[w] 代表存储是顶点w是从哪个前驱顶点遍历过来的。

结合图考虑：

1. 顶点0为第一个顶点，放入到队列中；visited初始化大部分是false，而0的位置初始化1，prev初始化-1.
2. 0出队后，与0相连的数字入队，visited 1，3位置设置为1,prev 1 和3 设置为0，前驱节点。
3. 然后1 出队（**这里没有想明白为啥先是1，代码实现的时候在考虑**），将与1相连的顶点放入到队列中，visited 2与4的位置设置为1，prev的2，4的位置内容设置为出队的1.
4. 3 出队重复3的步骤。
5. 4出队，就把6与5的内容放入到队列中，visited中5，6的位置设置为1，prev的数组内容设置为出队的4.

这样就找到了整个最短的路径内容

### 复杂度

复杂度分为空间复杂度与时间复杂度

- 时间复杂度：最坏情况下每个节点都需要访问一下，遍历整个图，进队列出队列，每个边也访问。时间复杂度就是0(边+顶点)，对于链接图来说边肯定大于顶点，简单的说可以使O(边)。
- 空间复杂度:需要使用的是上面三个辅助变量，最大不会超过顶点的个数，则时间复杂度是O(顶点的个数)

## 深度优先搜索

走迷宫的方式。

![2019-05-15-23-50-32](http://jikelearn.cn/2019-05-15-23-50-32.png)

```Java
//todo

```

### 复杂度

- 时间复杂度：进入再回退，时间复杂度是O(边的个数)。
- 空间复杂度：消耗两个数组与递归调用栈。数组大小跟个数V成正比，调用栈不超过顶点的个数，根据规则空间复杂度是O(V) V代表的是边的个数.