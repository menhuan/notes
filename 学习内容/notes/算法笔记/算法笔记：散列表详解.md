# 设计散列表

散列函数的设计要求：

1. 散列函数生成值尽可能**均匀随机分布**。
2. 设计不能复杂，避免计算hash值消耗的时间长，导致性能落后。

## 装载因子

装载因子越大代表散列表中的元素就越多，空闲位置就会少。

则数据状态就需要进行动态的变化，当数组占所有数据比例超过装载因子默认值，就动态开起数据的扩容。

扩容的时候需要三个步骤

1. 申请内存空间。
2. 需要对老数据进行重新的hash计算。
3. 数据的迁移。

缩容的也是同样的步骤

1. 减少内存空间
2. 对老数据进行重新的hash计算
3. 数据的迁移

再三个步骤中，我们说下数据的迁移，如果在扩容的时候数据有很多，那么先迁移老数据，在插入新数据的方式就会很慢。

这样一次性的扩容方式就不适合我们操作了，改成一边插入新的数据到散列表中，一边计算老的数据放入新的散列表中。

这样就能保证数据插入的操作很快速。

但有个问题就是这期间的查询怎么解决？

这是个数据迁移的问题，在数据没有迁移完成的时候，会先去新表中查找数据，没有查找到再去老的散列表中查询。

## 解决冲突

前一次笔记中，我们了解到散列表中是会存在散列冲突的，并且提供两种方式解决。

### 开放寻址法

数组的方式存储数据，然后线性寻找数据，寻找到hash位置，如果冲突，那么查找到空闲的位置放置数据。

该方式适合装载因子小，数据量小的方式，其中Java中的ThreadLocalMap 就是使用的该方式实现。

### 链表法

链表对内存的使用率比开放寻址法要高。链表法不需要寻求内存的数据。

在Java HashMap 中采用了该方式。

采用桶/槽的方式，后面挂链表，链表中的数据是冲突的数据这样即使hash冲突很多，变化也就是链表的长度，在Java8中链表的长度大于8就会自动的树化。 树化后的时间复杂度是O(log(n))。
