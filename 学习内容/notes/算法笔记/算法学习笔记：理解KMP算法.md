# KMP算法

KMP算法的目的是 在模式串与主串匹配的过程中，当遇到坏字符后，对于已经比较过的好前缀，将模式串一次性滑动很多位。

## 两个概念

- **最长可匹配后缀子串**：好前缀中所有的后缀子串中，最长的可匹配前缀子串的那个后缀子串。
- **最长可匹配前缀子串**：最长可匹配后缀子串所对应的前缀子串。

![2019-05-28-23-31-22](http://jikelearn.cn/2019-05-28-23-31-22.png)

### 求解两个子串

通过模式串在求解，因为好前缀子串都是出自模式串中，通过预处理的方式将其求解好。在计算的时候直接拿来使用即可。

**next数组/失效函数**:KMP 算法是将预处理的内容构建一个数组，数组的值 是**每个前缀中最长可匹配前缀子串的结尾字符下标**。数组的下标是每个**前缀结尾字符下标**。
![2019-05-28-23-57-54](http://jikelearn.cn/2019-05-28-23-57-54.png)

将模式串从左向右移动查找规律，匹配的模式串前缀

```Java
// todo 代码实现
```

### 失效函数的计算

![2019-05-29-23-09-48](http://jikelearn.cn/2019-05-29-23-09-48.png)

失效函数的计算法则是比如要计算next数组中某个位置的内容，比如next[4]，则我们从模式串中取出前5位字符串。

将其后缀从后往前排列展示出来。然后跟模式串的前缀进行匹配，则可以计算出next数组对应的值。

#### 连续计算next数组

在前面可以计算出next[0],next[1].....next[n]数组。

是否可以根据前面的计算推导出后面的next[n]数据内容。

注意next数组下标是**每个前缀结尾字符下标**，值是这个前缀的最长可以匹配**前缀子串的结尾字符下标**。

next[i-1]=k-1 则代表子串[0,k-1]是主串[0,i-1]的**最长可匹配前缀子串**。

则分两种情况。

- 如果[k]与[i]相等，那么next[i]=k，子串[0，k]是主串[0，i]的最长可匹配前缀子串。
- 如果不相等则需要换另外一个方法。寻找到次长的可匹配后缀子串。
   详解内容：
   - 次长的可匹配后缀子串肯定包含在最长可匹配后缀子串中。
   - 最长可匹配后缀子串b[0,i-1]，对应最长可匹配前缀子串b[0,y]
   - 查找次长可匹配后缀子串变成查找b[0,y]的最长可匹配后缀子串的问题。
   - 次长找不到，在寻找次次长的后缀子串。

![2019-05-29-23-52-38](http://jikelearn.cn/2019-05-29-23-52-38.png)。

```Java
//todo 代码实现
```

### 复杂度

复杂度分为两种，空间复杂度与时间复杂度

#### 空间复杂度

算法需要一个额外的next数组，数组大小跟模式串的大小一致。则时间复杂度是O(m),m表示模式串的长度。

#### 时间复杂度
