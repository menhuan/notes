根据时间复杂度进行了区分：
![摘自极客时间](https://upload-images.jianshu.io/upload_images/4237685-ea586820281f6792.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

# 分析排序算法
从以下几个方面进行入手分析。
#### 排序算法的执行效率
- 最好情况，最坏情况，平均情况时间复杂度。
- 时间复杂度的系数，常数，低阶
数据量小的时候，这些参数具有可参考性。
- 比较次数和交换次数

#### 排序算法的内存损耗
原地排序算法:空间复杂度是O(1)的排序算法。
#### 排序算法的稳定性
待排序的序列中存在等值的元素，经过排序后想等元素之间原有的先后顺序不变。
# 冒泡排序
冒泡排序：只会操作相邻的两个数据，每次冒泡操作都会对相邻的元素进行比较；不满足条件就进行交换；一次冒泡操作会把一个元素放到应该到的位置。
重复n次就完成了n个数据的排序工作。
```
实现冒泡排序的算法
```
#### 冒泡排序是原地排序吗？
答案是。每次交换数据需要的常量级的空间，时间复杂度是O(1)
####稳定的排序算法
只改变大小有差异的两者数据，相等的不需要操作。故事稳定的排序算法
#### 时间复杂度
- 最好的情况是O(N)
- 最坏的情况是O(N*N).因为每个值都需要移动,N个值移动，一个值需要移动N次
- 平均时间复杂度
采用有序度与逆序度来分析平均时间复杂度
有序度：具有有序关系的**元素对**的个数
![有序度](https://upload-images.jianshu.io/upload_images/4237685-6d4170c77a0eb4bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
满序对：n*(n-1)/2 
逆序对：与有序对概念反过来。
满序对=有序对+逆序对。
平均情况下需要n*(n-1)/4的情况下操作。比较操作比交换操作多，复杂的时间复杂度是O（N*N）.平均情况下也是O(N*N)
# 插入排序
动态的插入数据，保持集合中的数据有序。
数据分为两组，已排序区间与为排序区间。
核心思想：取**未排序**区间中的元素，在已排序区间中找到合适的位置将其插入。直到未排序的元素为空，算法结束。
两种操作：比较与移动。插入之后需要把后面的元素后移一个位置,腾出地方给新元素插入。
移动的次数是固定的，就是逆序度。
```
代码实现等待
```
#### 原地排序
符合。空间复杂度是O(1),运行期间不需要额外的元素
#### 稳定的排序
数据相等的，数据不会做迁移。稳定的排序算法。
#### 时间复杂度。
最好是O(N)
最坏是O( N^2 )
平均是O(N^2)
# 选择排序
区分**已排区间**与**未排区间**，每次排序会把从未排序区间找到的最小元素放到已排序件的末尾。
![选择排序](https://upload-images.jianshu.io/upload_images/4237685-b0c3dee5273b78da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```
代码实现周六日
```
#### 原地排序
空间复杂度是O(1),属于原地排序。
####稳定排序
不属于稳定的排序
#### 时间复杂度
最好是O(N)
最坏是O( N^2 )
平均是O(N^2)

#选择插入比冒泡好
在于冒泡需要在交换的时候进行三次操作。插入排序进行一次操作即可，随着数据量的增加3N的时间会远远大于N的时间量
