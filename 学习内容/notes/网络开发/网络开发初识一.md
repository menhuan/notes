####简介
   >由于最近公司最近的一个项目是要用到udp网络开发。自己原先也没有了解其中的知识，趁着这次机会。自己也开始从投头开始了解下，并且在文章中也会增加一些公司中遇到问题的并且给出解决方案。本系列只是用来了解下相关知识，刚开始只是最浅显的知识层次介绍。
###有关网络编程相关的内容
  #### 1. 网络
   >1    网络几乎是可以是相互发送和接收数据的计算机和其他设备的集合。  网络中的每台机器称为一个节点。节点一词指代网络的所有设备。每个网络节点都有自己的地址，这个用于唯一标识节点的一个字节序列。可以当作成数字，但是 不能保证的是地址中的字节数或者字节序与java中的简单数值类型一致。地址中的字节越多，可以接入的设备越多。
>2 在现代的计算机中 **计算机网络** 都是包交换：流经网络的数据分割成小块，称为包 。每个包都可以进行单独处理。并且每个包都包含由谁发送和将发送何处的信息。分包 可以使 建立的网络成本更低 ，多个计算机可以公用同一个网络线缆。 分包还有一个好处是 检验包在传输中是否遭到了破坏。
>3 协议： 是定义计算机如何通信的一组明确的规则：包括地址格式，数据如何分包等。协议有很多种如HTTP。
#### 2. 网络的分层
  >1网络上有好几种不同的分层，我们这里主要是采用了Internet的标准TCP/IP四层模型。 
![分层模型](http://upload-images.jianshu.io/upload_images/4237685-f397b0e3cc74de73.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
#### 流的信息
##### 1. 输出流 OutputStream
 > 1.常用的方法是write(int b) ,接受一个0 到255的 整数参数。将对应的字节 写入到输出流中。这个是写入的无字符字节。当然还有其他延伸的方法 write(byte[] bytes , int offset ,int length) .写入多个数据
> 2. flush() 方法刷新。发送完数据 使用flush发放将数据刷新，强制发送出去，防止 缓存区数据没有满，一直处于等待的地步。
>3. close()当发送完数据将流关闭。我们原先操作一般都是将流显示的放到finally中关闭。现在再java中我们可以用try（）{}catch(){} 在try中写入 我们需要关闭的资源 ，这种称为带资源的try。try块会自动的完成这个清理。
##### 2. 输入流 InputStream
> 1. 常用的方法是read()，跟输出流中的write方法对应，read读取一字节，read(byte[] bytes),读取指定字节,结束判断是根据其结果返回的是-1代表流读取完毕。skip()方法是跳过数据 不读取。availabe()方法来判断 流是否还存活着。close()将其 关闭。
> 2. 标记和重置方法。 mark(int readAheadLimit) 标记当前流的位置。在以后的某个时刻可以把流充值到之前标记的位置。让接下来的操作继续从标记的位置开始读取数据。 从标记处读取 和重置的字节数 由mark方法中的参数指定。标记的太大的话容日爆出IO异常。 并且一个流只能有一个标记，如果在一个留上标记多个的话，会前面的标记清除，保留最后的标记。
####3. 过滤器流
>1. 过滤器流的存在是因为前两个流只能单个或者成组的读/写字节。但仅此而已。过滤器流有两个版本。过滤器流以及阅读器和书写器。 
>2. 过滤器流将其构造函数与流链接。比如我们常用的读写文件的流. FileInputStream fin = new FileInputStream("content.txt");  BufferedInputStream bin = mew BufferedInputStream(fin)；将流串联起来。
>3. PrintStream 过滤器流。。 我们通常用的System.out 就是一个PrintStream 流。  不过我们还可以用构造 方法把其他流串联到PrintStream中。但是PrintStream 有两个问题 一是 println 的输出 与平台有关 ，取决于 运行代码的机器。换行的时候容易出现问题。 第二个问题是 采用所在平台的默认编码，这样的编码容易出现问题无法理解其中的内容。第三个问题 会把异常全部不吞掉 ，不能显示的处理
#### 4. 缓冲流
> 1. BufferedOutputStream 类将写入的数据存储在缓冲区中。 直到缓冲区满活刷新输出流。然后间数据一次全部写入底层输出流。这样一次写入多字节，比多次写入少量字节 相比 ，前者要快的很多。 BufferedOutputStream  在读取数据的时候有一个缓冲自己数组，当调用流的read方法的时候。首先尝试从缓冲区中获取数据，读取不到数据时才会从底层的源中获取数据。并且在这个时候从源中 读取尽可能多的数据存入缓存中。而不管是否马上需要这么多的数据。例如这两个构造参数 可以自己制定缓冲的大小 public BufferedInputStream(InputStream in , int bufferSize ) 。 bufferSize 就代表缓冲的大小。
#### 5. 数据流
>1. DataInputStream 和DataOutputStream 提供了一些方法。 采用二级制格式读写java的基本数据类型和字符串。同样的有读写的方法根据具体格式选择。





