# 跨主机网络

Flannel项目思考起来。 Flnannel项目是一个框架，后端实现三种方式提供容器的网络功能。

- VXLAN
- host-gw
- UDP

## UDP

三种方式中最差的一种实现方式。但又是最早的实现方式，用来参考学习。

构建两个不同主机网络。

1. 宿主机1容器1，ip地址是100.96.1.2，docker0网桥地址是100.96.1.1/24；
2. 宿主机2容器2，ip地址是100.96.2.3，docker0网桥地址是100.96.2.1/24;

从容器1发送ip包源地址就是100.96.1.2，目的ip地址就是100.96.2.3,但容器1与容器2不在同一个宿主机上，则ip也没有挂载在同一个网桥下。则无法访问。

但我们知道IP包的去下一个目的地，取决于宿主机上的路由规则。通过Flannel创建一系列的路由规则。

1. 宿主机1容器1发送出IP包，包含目的地IP地址信息.进入到docker0二层交换机上。
2. 通过Flannel创建的路由规则路由到flannel0设备上。ps 就是一个Tunnel设备。Tunnel设备在Linux中是工作在三层的虚拟网络设备。用来**在操作系统内核和用户程序之间传递IP包**。
3. flannel0会把Ip包交给创建这个设备的应用程序，就是Flannel进程。内核态往用户态流动。
4. Flannedl看到这个Ip包的目的地址，就将其内容发送到宿主机2上。ps：通过子网的方式来知道目标地址IP存在于哪个宿主机上。每个Flannedl进程都在Etcd中保存着宿主机与子网之间的关联关系。根据IP地址找到子网，根据子网找到目的IP。
5. 在发送给宿主机2之前会先封装一个UDP包，在每个宿主机上flanneld监听8285端口。用来接受发送过来的数据包。
6. 宿主机2的Flannedl接受到数据后，执行5->1的过程。然后容器2就可以接收到数据了。

![2019-07-10-23-15-48](http://jikelearn.cn/2019-07-10-23-15-48.png)。

性能问题：经过的用户态与内核态交互次数太多。从容器发送数据到docker0网桥，再从flannel0到flanneld用户态，然后到跟外部打交道的网卡内核态。三次交互。接收端也是同样的执行流程。性能消耗大。

系统级编程，重要的优化原则是**减少用户态到内核态的切换次数，把核心的处理逻辑放到内核态执行。**

