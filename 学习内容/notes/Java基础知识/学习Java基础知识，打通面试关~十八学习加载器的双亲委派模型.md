在上篇的文章中我们学习了Java中怎么进行类的加载，从加载，验证，准备，解析，初始化这几个阶段进行。其中验证，准备，解析可以共同解释为链接该阶段。我们平常在生活中使用某个物品都会先有其他东西才会使用现在的物品，比如大家在吃饭的时候需要有食物，还有碗筷子等等物品。当然我在这里说的中餐哈。
我门在Java也有自己的加载器，这是用来实现加载的过程所必须的物品。
# 类加载器
在Java中有两种不同的类加载器：一个是启动类加载器，该加载器是虚拟机的一部分，另外一个加载器就是其他类加载器也可以说是自定义类加载器。
## 启动类加载器
启动类加载器是负责将存放在JAVA_HOME>lib目录中的符合正确规则的类库进行加载到虚拟机内存当中。
## 自定义类加载器
在java中自定义类加载器分为两类一种是扩展类加载器，还有就是应用程序类加载器，不同的是扩展类加载器是可以让开发者直接使用的。应用程序类加载器如果用户没有自定义自己的加载器那么直接使用ClassLoader中的加载器getSystemClassLoader（）来得到返回值。
## 类加载器的双亲委派模型
我们前面看到几种类加载器，我们的主题是双亲委派模型，那么该概念是什么呢？
简单来说就是当类加载器尝试加载某个类型的时候，除非附加载器找不到对应的类型，尽量将任务代理给当前的加载器的父加载器去操作。目的是避免重复加载Java类型。 
**通常类加载机制有三个基本特征：**
![双亲委派模型](https://upload-images.jianshu.io/upload_images/4237685-043e6941edcacdc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
1. 双亲委派模型如图所示结构,但是并不是所有的加载过程都是按照这样的模式进行的。有自己的其他的模型，比如上下文加载器。
2. 可见性：子类加载器可以访问父类加载器，但是不能反过来操作。
3. 单一性：父类加载过的类型，不会在子类加载器中重复出现。
整个流程基本上是如此，那么我们程序需要加载这么多内容，那么会不会导致程序变慢，随着资源越来越多个的情况下，在此基础上java在发张的过程中已经开始了进行解决方案的尝试我们会在Java9以后的源码中可以看到Java对其加载过程的尝试。
