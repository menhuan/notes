上一节我们探讨了垃圾回收算法，简单的了解下垃圾回收在程序虚拟机中是怎样运行的。我们平常在开发中经常用的虚拟机是HotSpot，那么该虚拟机是怎样实现的呢？
# HotSpot 算法的实现
   我们知道在对象创建时候都会形成一条链，我们的可达性分析就是从GC Root节点上找引用的，其中这个节点主要是在全局性的引用于与执行上下文中。由于以下原因导致。我们现在虚拟机大部分使用的是准确式GC
  - 现在程序很多数据都是在数百M设置是数百GB,如果还要逐个检查每个引用，就容易出现问题。性能损失很多。
  - 还有一点就是可达性分析还对GC停顿敏感。
  准确式GC,不需要逐个检查每个节点数据，虚拟机有自己的方法指导数据存放在哪里。HotSpot 采用的是OopMap的数据结构来实现的。在进行JIT编译时，会在特定位置记录下栈和寄存器中哪些位置是引用，等GC扫描的时候可以直接得到这些信息。
  ## 安全点
   上面所说我们使用OopMap来实现引用的查找，并且还有在特定的位置记录该信息，这条信息就是安全点。并且由于安全点的存在，我们也没有必要为每条指令生成OopMap。当gc执行到安全点的时候才会停顿下来。
   安全点的选择在程序中为了保持程序执行的稳定性，选定安全点一般不能太少让gc等待之间过长，但是也不能太频繁增加系统的运行负载。这样情况下 向方法调用，循环跳转，异常跳转这些点容易产生安全点。
   说完对于某个点的gc，那么在gc的时候虚拟机不能一遇到安全点就去执行gc，那么十分容易导致gc平凡，甚至让程序无法执行下去。所以在GC的时候一般会选择让所有线程都跑到安全点的时候在停顿下来。其中业界采用了两种方案：抢先式中断和主动式中断。
   - 抢先式中断：会让所有的线程全部中断，但是如果有的线程不是停在安全点就恢复其跑到安全点，在进行中断。
  - 主动式中断：gc需要中断的时候，不直接对线程操作。就是设置一个标志，当执行到标志位时判断为真就自己中断挂起。
## 安全区域
  安全点让我们发现程序在执行的时候进行gc情况，但是如果长时间不执行呢？这样就无法进行到安全点，就无法执行jvm的中断请求。在这种情况下出现了安全区域。
  - 安全区域：在一段代码中引用关系不会发生变化，在这个区域中的任意地方开始GC都是安全的。。安全区域其实是安全点的衍生。
 当程序执行到安全区域时，先标识自己进入安全区域，当jvm需要挂起GC时，直接处理标识安全区域的线程代码。在离开安全区域时某系统会检查是否完成GC活动，没有执行完毕需要等待gc完成在进行线程活动，执行完毕就让线程离开安全区域继续执行即可。
                                                 ***欢迎大家关注关注公众号***
![微信公众号二维码.jpg](https://upload-images.jianshu.io/upload_images/4237685-58b31be7dce04b52.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
