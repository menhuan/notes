# 方法内联上

方法内联含义：在编译的过程中遇到方法调用，将目标方法的体纳入编译范围之中，并取代原方法的优化手段。

## 作用

方法内联能帮助消除调用本身带来的性能开销，是即时编译优化里面最为重要的一环。

C2过程中，内联是在解析字节码的过程中完成的，需要内联，则开始解析目标方法的的字节码。

编译器在解析字节码的过程中，会生成IR图，然后在IR图上遇到方法调用进行内联的优化，并且将其进行转换，编译器再根据IR图的节点以及调度顺序生成机器码。

## 内联

内联在遇到方法调用的时候会根据**内联算法**判定当前的方法调用，需不需要执行内联，判定需要执行内联，编译器就开始解析方法的字节码，生成对应的IR图。
![2019-03-26-22-32-38](http://jikelearn.cn/2019-03-26-22-32-38.png)

当然除了进行将ir图进行替换编译器还需要完成三个操作。

1. 传入方法参数的节点替换为调用者方法所传入的参数对应的节点。
2. 调用者的方法IR图中，指向原方法的调用节点数据依赖将重新指向**被调用方法的返回节点**。
3. 被调用方法抛出某种类型的异常，而调用者方法也有该类型异常的处理器，即时编译器就会把被调用方法跑出来的路径，与调用者的异常处理器相连接。
4. 内联操作后，在接下来的操作中编译过程会对新的IR图进行更进一步的优化。

### 内联的条件

内联的越多，生成代码的执行效率越高，对于即时编译器来说，内联越多，编译时间也就越长，程序达到的峰值时间就会被推迟。

即时编译器不会无限制的进行内联，有具体的规则。

1. 自动拆箱会被内联，Throwable累的方法不能被其他类的方法内联。
2. -XX:CompileCommand中的inline指令指定的方法以及@ForceInline注解的方法会被内联

不支持怎么的内联呢？

1. 调用的字节码对应的符号引用未被解析，目标类没有初始化，或者本地方法。
2. C2不支持内联超过9层代码，可以进行设置。
3. 1层的直接递归调用。


 即时编译器根据方法调用指令，所在的程序路径的热度，目标方法的调用次数大小，以及内联的IR图大小判定方法是否被内联