前天我们在写Java技术讲解的时候说过引用现在在Java中分为四种类型，**强引用**,**软引用**，**弱引用**，**幻象引用**。
但是这几者之间有什么关系呢？
# Java中对象的可达性
在Java中我们都是通过分析来计算对象是否还是存活状态。不是存活状态的对象才能 被清理掉。那么这个分析就是称为可达性分析。这个算法的实现是建立在一系列称为GC Root 的对象作为起点的。根据这些起点往下面搜索。这样就构成了从头开始的多条支路的链式信息树。当最终对象是不可达的状态时就证明该对象已死，那么就可以可回收了。
** 那么什么样的对象可以称为GC ROOT呢？**
在 虚拟机书上是这么定义的
- 虚拟机栈中引用的对象  -- 虚拟机栈 线程私有的属性
- 方法区中静态属性引用的对象 
- 方法区中常量引用的对象   --方法区 与java堆一样都是各个线程共享的内存区域。
- 本地方法栈JNI引用的对象  --本地方法栈与虚拟机栈 作用类似。本地方法栈执行的是Navite方法服务

![可达性分析图](https://upload-images.jianshu.io/upload_images/4237685-27c7931a50e79a17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
在可达性分析上我们判断训话找那个的算法就是这么一个流程。这个过程中在finalize 对象会有一次自己拯救自己的方式，如果再次不拯救自己进入幻象中，那么就可以让其真正的进行回收。
-  **强引用 也就是强可达**：该对象可以让不同的线程通过各种引用访问的情况，简单来说就是我们新建的对象，在该线程中属于强可达状态
- **软可达** ： 只能通过软引用来达到的对象状态
- **弱可达**：弱引用状态的对象可达的装填
- **幻象可达**：  经过finalize之后的对象状态。没有引用能指向该对象
- **不可达状态**：对象可以清楚了。
# 垃圾回收算法
   说完对象的引用之后我们都知道对象在哪种状态会被回收，然而在Java中我们使用的是gc来进行回收的那么，gc是利用什么条件进行回收呢？我们说下gc的算法了解下。gc的算法分为**标记-清除算法**，**复制算法**，**标记-整理算法**，**分代收集算法**，四种算法
## 标记清除算法
  标记-清除算法，分为两个阶段，首先是标记回收对象，然后统一回收对象。这是回收算法中最简单的算法。这个算法有两个不足之处
 1. 首先该算法是效率不高。
 2. 清除之后会产生很多碎片化空间
  ![垃圾回收](https://upload-images.jianshu.io/upload_images/4237685-9b5948f536e1fc75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

 黑色 标记要清除的对象，白色未使用，黑色可回收。从图中可看到就算对象被回收之后造成了很多碎片空间，如果在程序运行的过程中创建了大对象，在空间中没有支持的空间，那么就会出现内存溢出的问题。
## 复制算法
  复制算法是在上一个算法中提高了效率的解决问题。一般会将内存一份为二，一般内存使用完毕后，将对付复制到空余的地方上，进行清理，但是这个有问题就是每次内存只能使用一般，虽然效率提高但是整体内存缩小了。这是最基础的分割方式，
    1. 在复制算法中将内存分为Eden和Survivor中存活着。
     2. 当要复制对象时，创建多余的Survivor 就接收到使用的Survivor上的数据，虚拟机会进行清理Edec和Survivor上的数据
    3. Survivor上的复制数据空间不足时，有其他内存进行担保。获得更多的数据
![复制算法](https://upload-images.jianshu.io/upload_images/4237685-c9531adc2018471c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这样我们在使用的时候就能使用多余的空间进行大对象的创建，不用担心空间不足的情况。
## 标记-整理算法
  标记-整理算法是在标记-清除算法和复制算法基础上进行扩展的一种，标记过程都是一样的类型。然后在对象处理进行空间清理，不同点在于会将可回收的对象移动到一段，整体进行清理，这样大空间也会有，不会造成碎片化。效率也高，也能整个内存都应用上
![标记-整理算法](https://upload-images.jianshu.io/upload_images/4237685-cd457b800a91f2c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
## 分代收集算法
  分代收集算法根据对象存活的时间不同，将其内存进行块分割，在每个快中进行各个级别的数据清理，该方式更加高效。对症下药
![琪琪基地](https://upload-images.jianshu.io/upload_images/4237685-ef12ed4ad9443e97.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
