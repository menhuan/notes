# 内存模型

内存模型的出现是为了防止数据竞争的干扰，其中一个重要的概念就是happens-before关系。

## happens-before

happens-before 关系是用来描述两个操作内存的可见性。内存操作有先有后，前面的数据对后面的操作具有可见性。

### 线程内的happens-before

同一个线程和程序控制流程中靠前的字节码先于靠后的字节码，但是执行的顺序不一定是从前往后，主要是后者如果对前者有数据依赖才会顺序执行，如果没有依赖数据的关系，即使字节码在流程的后面，也可能出现指令的重排。

### 线程间的happens-before

1. 解锁操作happens-before之后，对同一把锁进行加锁。
2. volatile字段的写操作happens-before之后，对同一字段的读操作。
3. 线程的启动操作，happens-before该线成的第一个操作。
4. 线程的最后一个操作，happens-before它的终止事件。
5. 线程对其他想爱你成 的终端操作happens-before
6. 构造器中的最后一个操作happens-before析构器的第一个操作。

并且者之间具有传递性。

只要这之间没有数据依赖，**即时编译器**，**处理器**，都可能对其进行重排序。

怎么解决重新排序呢？可以使用volatile字段。

我们volatile字段有刷新内存的作用，具有可见性，让其他线程看到数据的修改。

从上面线程间的happens-before 可以看到，volatile字段的写操作，对于该字段的读操作，会被其他线程看到刷新的新值，这就是volatile字段的作用。

**结局线程之间的数据竞争问题，主要是构造一个线程间的happens-before关系**。

## 内存模型的底层实现

通过**内存屏障**来禁止重排序的。

- 即时编译器，会针对上面提到的happens-before关系，把正在编译的方法上插入相应的，**读读**，**读写**，**写读**，以及**写写**内存屏障。不同的系统架构，内存屏障的操作会是不同的指令集。
- volatile强制刷新内存的机制，是因为volatile字段写操作之后的你村屏障用具体指令来代替。
  
## 锁，volatile字段，final字段与安全发布

根据线程间的happens-before,锁也有相应的限制。

### 解锁操作happens-before之后，对同一把锁进行加锁

发生happends-before之后也会进行强制内存的刷新，保证数据的可见性。但是注意只需要是**同一把锁**，不同的锁，不会出现，现在的情况。

volatile字段不止有强制刷新数据到内存，让其他线程可见的的作用，还有就是即时编译器无法将其分配到寄存器中，必须从内存中读取。

### final

final实例字段涉及新建对象发布的情况。新创建一个对象，让其他线程可见初始化的字段，**即时编译器**会在final字段的写操作后插入一个写写内存屏障，防止被优化。
