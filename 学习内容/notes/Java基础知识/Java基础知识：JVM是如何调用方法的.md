# 虚方法的调用
Java中所有非私有实例方法调用都会被编译成invokevirtual指令，接口调用都会被编译成invokeinterface指令。
均属于虚方法调用。
大多数情况下，Java虚拟机都需要根据调用者的动态类型，来确定虚方法调用的目标方法。称为动态绑定。

静态绑定调用静态方法的invokestatic指令。用于调用构造器，私有实例方法以及超类非私有实例方法的invokespecial指令。
final 的方法 也是静态绑定调用。

# 方法表
虚拟机是用空间换时间的策略来实现动态绑定。每个类生成一张方法表，快速定位目标。

本质是数组，然后每个数组元素指向一个当前类及其祖先类中的非私有的实例方法。

方法表满足两个特性：
1. 子类方法表中包含父类方法表中的所有方法。
2. 子类方法在方法表中的索引值与它重写的父类方法的索引值相同。

静态绑定的方法调用直接指向具体的目标方法。动态方法调用指向的是方法表中的索引值。

动态绑定是什么呢？根据调用者的实际类型，并在实际类型的虚方法表中没根据索引值或的目标方法，这个过程是动态绑定。

# 内联缓存
内联缓存是一种加快动态绑定的优化技术。能够缓存虚方法调用中调用者的动态类型，已经该类型所对应的目标方法。缓存汇总存在的虚方法，直接调用，缓存中不存在的则基于方法表的动态绑定。

多态的优化手段中，三个术语。
1. 单态，只有一种情况。
2. 多态，有限数量中状态的情况。
3. 超多态，更多种的情况。有一个数值来对应区分多态与超多态。

内联缓存分为三种，单态内敛缓存，多态内敛缓存，超多态内联缓存。

为了节省内存空间，Java虚拟机只采用单态内敛缓存，将记录调用者的动态类型，以及它所对应的目标方法。

在虚拟机中，缓存没有命中，虚拟机会重新使用动态绑定去方法表中查找。查找之后需要进行替换内联缓存中的记录，这里需要消耗一定的额外系统开销。

另一种选择是劣化为超多态状态。直接访问方法表，动态绑定目标方法。






