# 数据库的事务隔离

前端时间，公司内部遇到了一个问题，就是我们创建的同一批任务，别分配给了不同的实例去执行，导致线上的结果出现问题。
另一个组的leader说没有开启事务，设置下事务就可以。
数据库一出现一致性问题，就说开启事务，我就有点疑惑，数据库的事务到底是怎么保证一致性的。

在看下面的内容，我们可以先思考几个问题。
> 数据库的隔离级别都有什么？
> 数据库的MVVC视图是怎么实现的？
> 数据库的隔离级别是为了解决什么问题的？
看完上面三个问题，自己能回答上来几个呢？不急。我们继续往下看

## 数据库的事务

数据库的事务我们简单来说就是用来保证数据的正确性，它只有两个操作:事务要么成功，要么失败并进行回滚。

为什么这么做呢？这是因为一般我们进行事务操作，都会进行一组操作。比如你常见的金融转账。

在这个转账事务里面包含2个操作:

- 扣自己银行账户的钱 
- 给对应的账户添加收到的钱。

现在思考下，如果我们没有添加事务，那么会出现什么样的情况呢？

1. 如果先扣钱成功，执行给别人加钱失败。而钱已经扣了，对方没收到钱，你说怎么办？
2. 如果先给对方加钱，而扣你钱的时候没扣成功。这钱银行给的补助吗？嘿嘿，那银行肯定不开心。

所以了我们只能在这种操作中使用事务，来保证执行的成功与失败，失败了要进行回滚，保证扣钱的操作也不执行。

### 事务的ACID

事务具有四个特性，这四个特性简称为ACID

- 原子性Atomicity：同一组操作，要么做，要么不做，一组中的一两个执行成功不代表成功，所有成功才可以。这就是原子性，做或者不做（失败进行回滚）。
- 一致性Consistency:数据的一致性，就像上面的举例说的，你扣钱了，对方没加钱，那肯定不行。
- 隔离性Isolation：多个数据库操作同一条数据时，不能互相影响。不能你这边变动，那边数据空间就变换了。
- 持续性Durability: 事务结果提交后，变动就是永久性的，接下来的操作或者系统故障不能让这个记录丢失。

今天主要说的事务就是隔离。看看事务是怎么保证数据之间的隔离

### 事务的隔离级别

不同的事务隔离级别对应的不同的数据执行效率，隔离的越严格，那么执行的效率就约低下，下面的四个隔离级别是原来越严格。

- 读未提交(read uncommitted):指数据在事务执行时，还没有提交，其他事务就可以看到结果
- 读提交(read committed):指数据在其事务提交后，其他事务才能看到结果
- 可重复读(repeatable read):一个事务在执行过程中，看到的结果与其启动的时候看到的内容是一致的。启动的时候会创建一个视图快照，该事务状态下，会看的一致是这个视图快照内容，其他事务变更是看不到的。**注意是读取的过程，如果是更新，那么会采用当前读，就是其他事务的更新操作会拿到结果，用来保证数据一致性**
- 串行化(serializable):顾名思义，就是将多个事务进行串行化（读写过程中加锁，读写冲突，读读冲突），一个事务结束后，另外一个事务才能执行，带来的效果就是并行化不好，效率低下。

Mysql中

## 事务的启动方式

## 数据隔离是怎么实现的

### 数据更新

### 数据读取

## 总结
