# MySQL中的锁

不同的语言中我们都会看到锁的存在，锁是用来保证并发操作时**共享数据的正确性**。

MySQL中为了提高并发处理，同样也存在锁机制。今天我们就来了解下MySQL的锁都有什么。

本文目录如下

![MySQ锁目录](http://jikelearn.cn/img/20201115205547.png)

## MySQL的锁级别

在MySQL中根据锁的不同粒度，可以将锁分为**全局锁,表锁,行锁**。

![锁粒度](http://jikelearn.cn/img/20201012073840.png)

全局锁锁的粒度是最大的，同样的并发能力也是最弱的。
行锁锁的粒度是最小的，同样的并发能力是最强的。

其实还有一种**间隙锁**，但这种锁是用来解决幻读问题的，存在于隔离级别是可重复度的情况下才会存在。本次暂不进行分析。

## MySQL的全局锁

全局锁就是对整个数据库进行加锁，全局锁加锁后会让整个数据库处于只读的状态，不能进行其他增删改操作。

### 全局锁的使用原因

全局锁使用后，整个系统处于只读的状态，这样的全局锁基本上用于**数据库备份状态**，还有从库也是只读状态哦。

**为什么数据库备份的时候要进行加锁呢？**

数据库备份的时候会进行逻辑备份，备份完一个表，再备份另外一个表。

现在有用户进行消费，流水表增加一笔流水记录，然后订单表里面多了一个订单。

这时候如果备份先备份了订单表，再备份流水表，你会发现有了流水，但没有订单记录。

这就出现了**数据不一致**的情况，为了解决这个问题，备份的时候一定要进行锁表。

**加全局锁是为了保证备份数据的一致性。**

### 全局锁的使用方式

了解了为什么要用全局锁，那在MySQL中怎么使用全局锁呢？有两种方式。

- 全局数据库设置为只读`set global readonly=true`
- 使用FTWRL(FLush tables with read lock)

这两种方式不建议使用 `set global readonly=true`,有两个考虑

1. 我们经常会把数据库设置为只读用来判断是主库还是从库（从库一般只提供读的能力）。
2. 两个异常处理机制不同，FTWRL机制如果有异常发生，那么数据库会自动释放全局锁，保证数据库能处于正常的状态，而设置readonly，除非手动释放，否则整个数据库会一直处于只读状态。

给数据库加全局锁时，采用FTWRL(Flush tables with read lock)是好的方式，原因请看上面两个考虑。

## MySQL的表级锁

Mysql的表级锁可以分为两种，表锁和元数据锁(meta data lock**简称MDL**).

### 元数据锁MDL

DML锁的作用：用来保证读写的正确性。
用来防止当一个线程正在读取数据时，有另外一个线程对表结构进行变更(比如删除一列)，这时候就会出现表结构与数据对应不上的情况，程序就会出现异常。

MDL是隐式操作，当正在读取数据的时候，就不会有另外的线程来修改表结构。

### 表锁

表锁的语法是 lock talbes ... read/write, 当使用完毕后就可以使用unlock tables 主动释放锁。

加锁分为两种情况。

1. 在表上执行读锁，本线程与其他线程都只能读取该表数据，不能写数据。
2. 对表上加上写锁，该线程可以对本表进行读写，其他现成读写都会受到阻塞。

## MySQL的行锁

MySQL的行锁是在InnoDB引擎里面加入的,MyLSAM不支持行锁，行锁是加在索引上的。

讨论行锁都是建立在InnoDB引擎上。

了解行锁需要知道一个概念**两阶段锁**以及出现死锁应该怎么解决。

### 两阶段锁

两阶段锁是指**加锁阶段**和**解锁阶段**。行锁是在需要的时候加上，但并不是不需要了就立即释放，而是在事务提交后才释放。

注意，该两阶段锁是针对的单个MySQL的事务，不适用于分布式事务。

知道了两阶段锁，那么对于我们在写代码时应该怎么做呢？

在事务操作中，尽可能得把造成锁冲突，锁等待的语句放到后面，这样减少锁等待的时间，从而提高业务的并发度。

### 死锁与死锁解决

我们知道在锁中，经常出现死锁的问题。那什么是死锁呢？

死锁就是系统中出现互相等待资源状态，导致涉及到的线程拿不到锁资源，从而一直等待，却不停止。


**那怎么解决呢？**，这里提供量两种方式。

1. 设置锁等待的时间，在时间内获取不到锁信息，就当成失败处理，参数是innodb_lock_wait_timeout。
2. 使用MYSQL中自带的死锁检测，配置参数innodb_deadlock_detect=on,数据库发现死锁后会自己处理，处理方式是自动回滚(一个或者多个对事物代价较小请求)，**让执行代价比较大的优先执行**。

#### 方案1

方案1来说，对于线上并发比较大的程序来说超时时间设置长或者过短都不是一个好的方案。

- 过长，相当于在这段时间内这行数据不能被请求，如果有多个线程来请求，就必须等待，线上服务可能就直接崩溃。
- 过短, 那如果这段时间只是等待其他线程释放锁呢？可能被误判，这样系统很多操作都不能被执行。

简单的程序可以使用方案1，但对于线上要求比较高的系统来说方案1就不是可取方案。

#### 方案2

方案2. 死锁检索虽然好，但是对于并发系统来说，如果是同样的一行请求操作，都会加入到死锁判断请求。

一个线程检查死锁的时间消耗是O(N),其中N是指当前线程的数量。

举个例子，比如现在有第100个并发线程请求这一行数据，那么当前线程就需要检查 排队等待锁的线程中 是否会与当前线程出现互相等待锁资源的情况。
而100个线程就是100*100 =1万次检查，1000次就是`1000*1000=100 000次`。

这种情况对于线上系统来说就会形成数据库CPU消耗很高，但是单位时间内执行的事务并没有多少。

## 总结

Mysql 主要的锁结构就是数据库锁->表锁。

行锁是建立在Innodb引擎上的，而在MyISAM引擎中是没有行锁的。

本文中介绍了数据库全局锁加锁的方式，建议使用FTWRL(Flush tables with read lock)方式来设置数据库全局锁，另外的方式会涉及到从库只读的使用。

表锁是在使用Innodb引擎之前常用的并发控制手段，表锁除了锁数据之外，还会对表结构锁住(隐式加上)，防止在读取数据时候，别的操作修改表结构。

行锁是Innodb上的控制方式，行锁相对于表锁提高了并发度，并且也有两段锁机制，大大提高了并发度。除了行锁我们还了解数据库中的死锁的出现以及解决方案。

