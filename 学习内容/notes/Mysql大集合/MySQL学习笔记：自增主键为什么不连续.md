# 自增主键

自增主键 在查看的时候很多时候会发现并不符合我们想想要的连续。那么为什么会出现自增连续的空洞呢？

## 自增值的保存

在数据库中有专门的地方来保存自增主键的值。

表结构定义是存放在后缀名为.frm的文件中，但是并不保存自增值。

在数据库中，有不同的数据库引擎，那么不同的引擎出保存的策略不同。

- MyISAM 引擎的自增值保存在数据文件中。

- InnoDB引擎的自增值，在8.0版本之前是保存在内存上的。8.0以后的版本是增加了持久化的内容。
  
  1. 在内存中每次重启之后，打开表的时候，会重新查询表id的最大值，最大值+1 作为最新的自增值。这可能出现与原先的自增值不一致的情况，但不影响使用。
  
  2. 8.0版本，自增值保存在 redo log 日志中，重启之后可以依赖 redo log 来恢复前面的自增值。

## 自增值的修改机制

自增值的时候分为两种情况来插入。

1. 自增值 在插入的 指定 0、null、未指定值，把当前的自增值填充到自增字段中。

2. 插入数据时，id指定字段内容。
  
   - 插入的值 大于等于当前的自增值，就把当前的值设置为最新的自增值。

   - 插入的值小于自增值，那么这个表的自增值不变。

### 自增生成算法

两个系统参数：

1. auto_increment_offest :1 ;自增初始值
2. auto_increnment_increment :1 ; 步长

**注意：** 双主情境下，这些值需要修改。

### 自增值的修改时机

- 插入语句出现错误，但是自增值在表结构中已经做了自增改变。
  eg：比如现在是2 ，插入新的数据出现错误，但是自增值已经改为3，再次插入新的数据自增值会变为4.

- 数据出现回滚，自增值不会改变。

### 自增值为什么不能回退

假设主键可回退，目前自增值为2 ，并发执行，A与B，B执行成功，A执行在前，现在自增值为3 ，执行失败，但是B并行成功了，自增值已增加为4，那么A回退，回退3 为2 ，在插入数据为3 ，但是数据中已存在数据，就会出现主键冲突。

情景2: 每次都需要进行加锁，判断主键是否存在，申请主键性能降低。

情景3：锁的力度加大，事务执行完成之前，无法获取最新的自增值。

### 自增锁的优化

现在的版本设置，新增的一个参数autoinc_lock_mode。默认1

1. 参数0，语句执行后才释放。
2. 参数1
    - 普通insert语句，申请之后马上释放。
    - insert select批量插入语句,等语句结束后才释放。

3. 设置为2，自增主键的操作都是申请之后释放。

#### 疑问

1. insert...select 插入语句使用的是语句级别的锁。
2. 默认的参数值不是2 

这两者的设计目的都是为了保证数据的一致性。

当binlog 日志记录是 statement 的格式的时候，binlog 在备库里面生成的执行顺序会导致 数据与现在的库数据不一致的情况。

解决这种数据不一致的情况需要两种思路。

1. 原库生成连续的id值，自增锁直到语句结束才释放就是为了这个目的。

2. binlog 日志里面的内容都如实记录，到备库执行，不再依赖从库的自增主键去生成主键。 设置模式为2，同时binlog日志模式记录为row。

批量插入数据的语句有insert...select,replcae...select,load data语句。

普通的insert语句，这类语句在申请自增id的时候，会计算好需要申请多少个，一次性申请出来，申请完之后释放即可。

自增获取值的算法是：

1. 语句执行过程中先申请一个。
2. 第二次申请是上一次的两倍。
3. 循环上面2的过程。
4. 多余的自增id会被丢弃掉。

## 总结

三个主键不连续的情况。

1. 事务回滚。

2. 数据插入冲突，出现错误，但是自增值已经增加。

3. 批量插入，获取自增值已经扩展，但并没有利用完。








