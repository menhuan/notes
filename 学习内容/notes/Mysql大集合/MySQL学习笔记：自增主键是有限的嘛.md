# 自增主键有限

数据库中有好多种可以自增的数据库自增字段。

## 表定义的自增值id

一般建立表的自增id是 int(11)，最大值就是2^32 -1 .在插入的时候就会出现上限问题，可以改造成8个字节的bigint unsigned。

## InnoDB 系统自增的row_id

创建的数据库没有设置主键，InnoDB会创建一个长度为6字节的row_id。

并且会维护宇哥全局的dict_sys.row_id的值。所有无主键的InnoDB表，每插入一个新的数据，就将其作为数据的row_id，然后将dict_sys.id +1 .

- 最大值是2^48-1
- 如果超过这个值，再重0开始重新计数。
- 超过以上值会覆盖原先的行。
  
## Xid

Server 层维护的变量

redo log 与binlog中共同的一个字段是Xid.

是由 数据库内部维护了一个全局变量global_query_id。每次执行语句都将其赋值给语句的事务Xid. ，再将其加1即可。

纯内存变量，重启后就清0。在一个数据库实例中，不同的事务Xid是存在相同的，但重启之后生成**新的binlog文件**，同一个binlog日志中Xid是唯一的。

最大值是2^64 所以存在于理论上。

## Innodb trx_id

InnoDB内部使用的Xid，是为了跟InnoDB事务与server层之间做关联。

trx_id是另外维护的一直自增值。是我们在事务中使用到的事务id。

Innodb维护了一个max_trx_id 全局变量，每次申请一个trx_id，就获得max_trx_i的值，然后再将其加1.

- 对于只读事务的数据来说看到的trx_id 都是**把当前事务的trx变量 指针地址转为整数+2^48**，就是该值了。
- 不是只读事务的trx_id就是在执行不是只读事务操作的时候分配trx_id，会在此基础上+1，并且在update与delete删除语句的时候操作加+2因为涉及到把数据放到purge队列里等待物理删除的操作。
  
## thread_id

线程id,系统保存了一个全局变量thread_id_counter，每新建立一个连接就将其赋值给新连接的线程变量。

