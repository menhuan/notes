事务是保证一组数据库操作，要么完全成功，要么完全失败。在MySQL中事务支持是在引擎层实现的。有的引擎并不支持事务比如MylSAM引擎。
### 隔离性与隔离级别
事务操作涉及到ACID四个操作.
- 原子性(Atomicity)
- 一致性(Consistency)
- 隔离性(Lsolation)
- 持久性(Durability)

事务执行的时候会出现多个不同的读写情况，脏读，不可重复读，幻读等问题，为了解决这些问题，就有了隔离级别的概念。

- 读未提交：一个事务还没提交时，它的变更能被别的事务看到。
- 读提交：提交后，它 的变更才能别其他事务看到。
- 可重复读：事务执行过程中看到的数据，总是跟这个事务启动的时候看到的数据是一致的。未提交的变更对其他事务也是不可见的。
- 串行化：读写锁，会把同一行的数据进行加锁，冲突的时候，后访问的事务必须等到前一个事务执行完毕后才能继续执行。
案例说明：

事务中，数据库会创建一个试图，访问的时候以视图的逻辑结果为准。
- 可重复读级别下：视图是在事务启动创建的，整个事务存在期间都用这个视图。
- 读提交：视图是在SQL语句开始执行的时候创建。
- 读未提交：没有视图概念，直接返回记录上的最新值。
- 串行化：直接加锁的方式来避免并行访问。

事务的隔离方式可以通过字段transaction_isolation 来设置。
也可以通过 show varibales like 'transaction_isolation'来查看。
不同的业务设置不同的事务隔离级别。
### 事务隔离的实现
在MySQL中每条记录更新的时候都会同事记录一条回滚操作。记录最新值，通过回滚得到前一个状态的值。
案例截图操作：

同一个记录在系统中可以保存多个版本，这是数据库的多版本并发控制(MVCC).

回滚日志不会一直保存，在不需要的时候会被删除，这个时刻是系统里面没有比这个回滚日志更早的read-view的时候。

- 尽量不要使用长事务：
 长事务意味着系统里面会存在很老的事务视图，在这个事务提交之前，数据库里面可能用到的回滚记录必须保留，大量占用存储空间。
  
  长事务还占用锁资源，可能拖垮整个库。
### 事务的启动方式
事务的启动方式：
 - 显式调用事务，配套的提交语句是commit，回滚语句是rollback.
 - set autocommit =0 ,将自动提交关闭掉。执行一个语句，不执行commit 之前会一直存在。

事务启动建议通过显式的语句来启动事务。

commit work and chain是提交事务并且自动启动下一个事务，省去了再次执行begin语句的开销。能明确知道每个语句是否处于事务中。
可以通过语句查询持续时间超过多少秒的事务，具体google。

# 如何避免长事务对业务的影响
### 应用端
1. 检查 自动提交是否被关闭。将自动提交开启
2. 确认是否有不必要的只读事务，去掉不必要的只读事务。
3. 业务连接数据库的时候，设置 MAX_EXECUTION_TIME 控制每个语句执行的最长时间，避免单个语句意外执行太长时间。
### 数据库端
1. 监控 innodb_trx表，设置长事务阈值，超过报警或者kill。
2. Percona的 pt-kill  工具
3. 测试阶段输出所有的general_log日志。
4. 设置innodb_undo_tabespaces 设置为2 ，清理大事务回滚过大更方便。 


  




