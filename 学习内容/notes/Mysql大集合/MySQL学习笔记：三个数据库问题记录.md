# 三个小问题

## join的写法

- left join 左表不一定是驱动表
- 包含多个等值匹配，写到on里面还是写到where里面。

### 如果条件全部写入到on里面，驱动表会是左表依赖，使用explain检查使用的是什么算法，流程就可以知道。

BNL算法执行流程：

1. 左表内容读入到 join_buffer中，需要的字段放入到其中。
2. 顺序扫描被依赖表内容，将满足条件的记录。作为结果集的放回，如果语句中有wheret字句，先判断where 满足条件的语句。
3. 扫描完被驱动表之后，补全字段NULL，放入到结果集中。

### 条件写入到where条件中。驱动表不一定是左表依赖。

通过explain执行下检查使用的什么算法。
还有一个NLJ算法。

1. 顺序取出驱动表中的每一行数据，到被驱动表中全盘扫描。
2. 顺序便利被驱动表中的搜友航，每一行数据都跟join_buffer中数据匹配，作为结果集的一部分返回。
3. 在对表全盘扫描的时候，如果数据没有放入到BUffer Pool中，需要对被驱动表数据多次访问。
4. 被驱动表数据都在内存中，是指针的操作，而jon_buffer是数组，遍历的成本低。

在MySQL中 NULL与等值判断和不等值判断都是NULL。

### 结论

1. 在需要将左表作为驱动表的时候，条件全部写到on中。不需要作为驱动表可以写到where字句中。

2. join链接中写在on中与where中都是一样的。

## distinct 与 group by的性能

在group by 没有聚合函数的作用下，去重的效果与 distinct效果是一样的。

执行流程是：

1. 创建临时表，将字段放入进去，并且建立唯一索引。
2. 遍历表，一次取出数据插入临时表中。冲突跳过，否则插入。
3. 成功后，将结果集发送给客户端。

## 备库自增事件

环境： binlog 属于statement 格式下，自增id的生成顺序与binlog的写入顺序不同。

插入语句在执行的时候会在每个语句直线执行一句：

```SQL
SET INSERT_ID =1 ;//或者不同的数字
```

那么在备库上执行的效果也是一样的。

主备库的insert语句执行顺序不同，自增主键字段的值也不会不一致。
