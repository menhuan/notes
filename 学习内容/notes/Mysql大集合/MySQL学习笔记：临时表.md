# 临时表
临时表与内存表并不是一致的。

## 内存表
代表的使用Memory 引擎的表。在建立表的时候指定engine = memory .

## 临时表
临时表可以使用其他各种的引擎类型。比如我们所说的InnoDB.

# 为什么要使用临时表呢？
为什么使用临时表是由于这几个特点。
- 临时表只能被创建它的session所能看见与使用，对其他线程不可见。
- 临时表与普通的表明可以相同，因为在磁盘上存储的名字是不一样的，内存上显示的也不一样。
- 同一个session会话中，临时表与普通表存在，增删改查语句是访问的临时表。
- show tables 不显示临时表。
- session 结束后，临时表会被删除。

这样的情景下，临时表不担心表重复的问题，并且不担心数据删除问题。临时表有程序会自动回收。

# 临时表名重复
我们在前面所说，临时表属于自己的session当中的。

数据库的表示怎么存储在磁盘上的呢？ 普通表是放在普通表文件的目录下，临时表的存储是放在另外一个tmp的文件目录下。

临时表的名字存在构成也与临时表不同，临时表是在前缀的基础上+线程id+顺序的数字。

数据库除了在磁盘上维护这个关系外，还需要在内存上进行维护。
- 普通表采用的table_def_key 是由库名+表名 构成。
- 临时表才用的table_deg_key 是由库名+表名+servier_id+thread_id.

# 临时表与主备复制

虽然是临时表，但是我们在删除临时表的时候也会在binlog 日志中记录删除命令。

这是为什么呢？

如果binlog 格式= stament/mixed 的时候，我们在主库中执行创建临时表，然后执行操作。

以上内容，如果不在binlog上记录，在备库上执行就会出现临时表丢失的问题。所以binlog在该模式下还是需要的。

那row模式呢？ 这是不需要的。在row模式下知识记录操作逻辑，不会出现这个问题。

## 还有两个个问题
1. 执行 drop table 表，会出现变形。
```
drop table 'teble_name' /*gengrated by server */  有这个代表进行修改过。
```
这个命令时可以删除多个表的，是row 格式的话 备库上是没有临时表，所以需要语句的改写
2. 主库上不同线程创建的临时表在备库上怎么执行？
备库上的日志线程是共享的。在记录binlog的时候会记录每个语句主库执行的线程id。
- 在备库上的table_def_Key 就是 库名+表名+ 主库上的server_id+thread_id.
- 另外一个线程操作也是类似的。

两者最终的内容还是不一样的。

