# MySQL中引擎对比

## 内存表的数据结构组织

### InnoDB引擎

使用的是主键索引ID的组织方式。

表的数据放到是放到主键索引上，索引使用的是B+树。索引的顺序是有序的，在查找数据的时候根据查找到的店从左到右查找数据。

其他索引上保存的是主键id，这种被称为 索引组织表。

### Memory 引擎

该引擎数据与索引是分开的。数据是按照数组的方式单独存放，主键id索引里存储的是数据存放的位置。

索引是hash索引，所以索引上的key并不是有序的。

单独数据存放，索引上保存数据位置，这种是堆组织表。

### 两者不同

1. innoDB数据存放是有序的，内存表的数据是写入顺序存放。

2. 数据文件有空洞的存在：那么InnoDB插入数据的时候保证有序性，在固定位置插入，内存表找到空余的位置就执行插入。

3. 数据位置变化：InnoDB表只需要修改主键索引,主键索引存储的数据，其他索引保存的是主键索引;内存表需要修改所有索引，一个位置变动会导致多个数据变动，索引需要改变。

4. 使用索引查找数据：InnoDB主键索引需要走一遍数据，普通索引需要查找两遍，当然可以使用覆盖索引的方式，采用一遍;内存表，索引的地位都是一致的。

5. InnoDB 支持变长数据类型。内存表不支持Text和Blob字段。内动是定长的。

## hash 索引与B-Tree索引

内存表中也是支持 B+索引的，使用增加索引的方式即可增加。

```Mysql
alter table tableName add  a_btree_index using btree(column);
```

## 不建议生产上使用内存表

1. 内存表不支持行锁，支持表锁，锁的力度大。并发情况下，性能差。

2. 数据持久化：数据都是放在内存当中，数据库出现异常重启，那么内存表的数据就会被清空。数据没有了就会导致出现问题。
  
   - 在主备库中，备库异常重启，内存表被清空。主库的binlog发送过来更新这个数据表，就出现数据不一致的情景。主备同步就会停止。

   - 双主结构下，主库内存表会出现删除数据的情景。